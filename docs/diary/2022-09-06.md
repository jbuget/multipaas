# 2022-09-06 - R√©flexions techniques

## Gateway vs. proxy vs. tunnel

@VincentHardouin m'a remont√© qu'il n'aime pas le terme "gateway" pour d√©signer la brique qui va faire passe-plat de requ√™tes HTTP.

Je m'√©tais d√©j√† pos√© la question avant de lui l√¢cher le terme.

J'ai creus√© plusieurs pistes / articles :
- [Serveur Fault](https://serverfault.com/questions/994319/what-is-the-difference-between-a-proxy-server-and-a-gateway-server)
- [Stack Overflow](https://stackoverflow.com/a/34284700/2120773)
- [Akana](https://www.akana.com/blog/api-proxy-vs-api-gateway)

Je n'arrive pas √† trouver de r√©ponse claire, satisfaisante et d√©finitive.
Faute de mieux, je reste sur "gateway".

## Architecture technique

### DNS

Il faut que `app-1.gateway.example.com`, `app-2.gateway.example.com` et `app-n.gateway.example.com` redirige respectivement vers `app-1.scalingo.com`, `app-2.scalingo.com` et `app-n.scalingo.com`.

Mon id√©e est de d√©finir 2 entr√©es `CNAME` : 
```shell
# Zone DNS pour example.com

gateway.example.com   CNAME paastis-gateway.scalingo.com
*.gateway.example.com CNAME gateway.example.com
```

Il faut que le FQDN de l'app "paastis-gateway" soit associ√© c√¥t√© Scalingo au DNS `gateway.example.com`.

Si tout se passe comme je le pense / l'esp√®re, √ßa devrait fonctionner ü§û. 

### Int√©ragir avec Scalingo

Par souci de simplicit√©, je d√©cide de passer par leur client JavaScript.

Scalingo l'a mis √† jour il n'y a pas si longtemps.

Le d√©faut est qu'il ne g√®re pas le multi-r√©gions.
Je suis donc oblig√© de g√©n√©rer 2 clients.
J'en fais des singletons.

> ‚ö†Ô∏è Il faudra g√©rer le cas du refresh de token.

√áa semble plut√¥t bien fonctionner.
Je craignais de me faire ban ou rate limit.
Pour le moment, avec une vingtaine d'apps et malgr√© de nombreux refresh de page, √ßa passe üëç.

### Registre des apps

La solution qui me para√Æt la plus simple (et performante ?) est de conserver √† tout moment un "registre des applications actives". 

Pour √™tre en capacit√© d'avoir une gateway multi-instances, je d√©cide de conserver le registre dans un Redis.

| App name | Last request datetime |
|----------|-----------------------|
| app-1    | 2022-09-06_17:39:09   |
| app-2    | 2022-09-06_17:17:54   |
| app-n    | 2022-09-06_17:23:31   |

Lorsqu'on re√ßoit une requ√™te, on regarde si l'app est dans le registre.

Si "non", alors on r√©veille l'app sur Scalingo et on ajoute une entr√©e dans Redis.

> Je ne suis pas certain qu'il soit n√©cessaire de stocker la date de derni√®re requ√™te.
> Je pense qu'il est possible de d√©finir la dur√©e de vie de r√©tention de l'entr√©e Redis au moment de l'ajout.
> En r√©fl√©chissant mieux, si je suis oblig√©.
> Il ne faudrait pas que Redis vire l'entr√©e et que je perde l'info sans avoir pu √©teindre l'app Scalingo.

Pour le multi-instances, on peut peut-√™tre ajouter une entr√©e particul√®re `last_check` pour que seule la premi√®re instance qui fait le check lance l'auto)pause des apps.

Avec ce genre de m√©canisme, si une application est ajout√©e, le premier qui tente d'y acc√©der ajoutera l'entr√©e.

### R√©veil d'une app

Il faut pr√©voir un m√©canisme qui v√©rifie toutes les 6 secondes (pour faire 6 * 10 = 60s) qu'une app est correctement restart√©e. 

### Cron

Plusieurs pistes possibles : 
- node-cron
- pgboss
- BullMQ

Je pense - et @VincentHardouin est align√© - que dans un premier temps, on peut se contenter d'un simple `node-cron`.

## Impl√©mentation

J'ai cr√©√© une app [hello-fastify](https://github.com/jbuget/hello-fastify) pour tester la gateway.

Micro p√©touille avec le multi-r√©gion Scalingo.
Quant on register un proxy Fastify pour une app, il faut penser √† tenir compte de la r√©gion pour l'upstream.
