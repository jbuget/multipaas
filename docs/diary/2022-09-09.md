# 2022-09-09 - 

## ‚úÖ It works again!

Aujourd'hui, rien ne fonctionne correctement.
Depuis hier et quelques modifs, impossible de d√©ployer et scaler correctement l'application Scalingo `paastis-proxy`.

Rahhh‚Ä¶ C'√©tait tout bidon.
Quand j'ai mis en place la config, j'ai mis `localhost` en host par d√©faut plut√¥t que `0.0.0.0`.
Et donc, selon les r√®gles de Scalingo, l'application n'√©coutait pas correctement le bon host + port.
Pfff‚Ä¶ 2h de perdues pour une b√™tise.

## üö¶ Supervisor, Redis & POO

Redis va permettre d'avoir du scaling horizontal.
Toutes les instances de `paastis-proxy` vont pouvoir s'appuyer sur une seule et m√™me source de v√©rit√©.

L'un des soucis, c'est qu'en l'√©tat, on peut avoir plusieurs instances qui tentent de d√©marrer ou couper une m√™me app en m√™me temps (ou dans un temps trop court).

Plusieurs solutions :
- sortir le cron dans un nouveau processus, mais d√©pendant du mode de fonctionnement de Scalingo / Heroku. Pas tr√®s host-provider agnostic
- sortir le cron dans un nouveau module/workspace `paastis-supervisor`
- avoir une cl√© `last_checked_at` dans Redis, mais il faut s'assurer qu'on locke bien la base

Quoi qu'il en soit, l'id√©e est de supporter 2 types de index store :
- `in-memory`
- `redis`

Pour √ßa, on va utiliser les m√©canismes (tr√®s basiques) de POO de JavaScript.

J'avais oubli√© que Redis ne stocke que des Strings.

```javascript
  async get(appName) {
    return JSON.parse(await this._redisClient.get(appName));
  }

  async set(appName, managedApp) {
    return await this._redisClient.set(appName, JSON.stringify(managedApp));
  }
```

Comme d'hab, des soucis de date √† g√©rer : 

```javascript
export default class RunningApp {

  constructor(name, region, startedAt, lastAccessedAt) {
    const now = new Date();
    this._name = name;
    this._region = region;

    if (startedAt) {
      this._startedAt = ((typeof startedAt) !== 'Date') ? new Date(startedAt) : startedAt;
    } else {
      this._startedAt = now;
    }

    if (lastAccessedAt) {
      this._lastAccessedAt = ((typeof lastAccessedAt) !== 'Date') ? new Date(lastAccessedAt) : lastAccessedAt;
    } else {
      this._lastAccessedAt = now;
    }
  }
}
```

### Variables d'environnement

Autre souci, quand on ajoute un addon Redis dans Scalingo, il ajoute les 2 variables d'environnement suivantes :
- `SCALINGO_REDIS_URL=redis://:{generated_password}@{app_instance}.redis.a.osc-fr1.scalingo-dbs.com:{port}`
- `REDIS_URL=$SCALINGO_REDIS_URL`

L'interpolation ne fonctionne qu'√† un niveau.

Et donc ajouter une troisi√®me variable `REGISTRY_REDIS_URL=$REDIS_URL` ne fonctionne pas.

### Design

J'ai opt√© pour un design qui s√©pare bien les responsabilit√©s :
- `index.js` ‚Üí fournit une instance (singleton) de `RunningAppRegistry`
- `RunningApp.js` ‚Üí la structure de donn√©e qui permet de monitorer les apps actives
- `RunningAppRegistry.js` ‚Üí ü§î classe englobante du store ; je me demande s'il y a vraiment un int√©r√™t √† conserver cette proxy-class
- `RunningAppRegistryStore.js` ‚Üí l√† o√π se passe la magie de stockage, r√©cup√©ration et modification de l'information ; 2 impl√©mentations sont disponibles : in-memory et Redis-based

## ü™ù Hooks before/after - start/stop

Il y a 2 fa√ßons d'ex√©cuter des commandes / scripts shell : 
- `child_process/exec`
- `child_process/spawn`

https://benborgers.com/posts/node-shell

